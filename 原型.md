每个对象都会有一个``__proto__`` 属性，``__proto__``又会有自己的``__proto__``，

从下面例子看出new 出来的对象跟prototype的关系

```javascript
var Fn = function(){}
var fn = new Fn()
fn.__proto__ === Fn.prototype  // true
fn.constructor === Fn.prototype.constructor === Fn
```



```var fn = new Fn()``` 相当于:

```javascript
var fn = {};
fn.__proto__ =  Fn.prototype;
Fn.call(fn);
```



```javascript
var A = function(){}
A.prototype.name = 'Tom'
A.prototype.sex = 'man'

var B = function(){}
B.prototype = new A()
B.prototype.name = 'Jerry'

var b = new B()

console.log(b.name) // Jerry
console.log(b.sex) // man
```

这里，`b.__proto__ = B.prototype`， `b.__proto__.__proto__ = A.prototype`

![](https://raw.githubusercontent.com/funyaliga/posts/master/img/QQ20171226-113118.png)	

可以看出，访问`b.sex`时，先看b自身有没有sex属性，没有就从原型`b.__proto__`属性中找，没有就从`b.__proto__.__proto__`找
 即`b.sex = b.sex || b.__proto__.sex || b.__proto__.__proto__.sex`



再举个例子

```javascript
var Fn = function(){}
var f1 = new Fn()
var f2 = new Fn()
Fn.prototype.name = "abc"
console.log(f1.name) // abc
console.log(f2.name) // abc
```

这时候打印出来的f1、f2结构分别是：
![](https://raw.githubusercontent.com/funyaliga/posts/master/img/proto1.png)

设置f1的name属性

```javascript
f1.name = 'xyz'
console.log(f1.name) // xyz
console.log(f2.name) // abc
```

这时f1、f2结构分别是：
![](https://raw.githubusercontent.com/funyaliga/posts/master/img/proto2.png)

可见实例会优先读取自身属性

删掉自身属性，又会恢复从\_\_proto\_\_获取

```javascript
delete f1.name
console.log(f1.name) // abc
console.log(f2.name) // abc
```

设置对象原型的属性会导致所有实例的变化

```javascript
Fn.prototype.name = "ABC"
console.log(f1.name) // ABC
console.log(f2.name) // ABC
```

![](https://raw.githubusercontent.com/funyaliga/posts/master/img/proto3.png)