[TOC]

## 作用域

作用域是指程序源代码中定义变量的区域。



## 执行上下文

当 JavaScript 代码执行一段可执行代码时，会创建对应的上下文(execution context)并将该上下文压入上下文栈（context stack）中。



执行期上下文：Activation Object，简称AO

全局对象：Global Object，简称GO

变量对象：variable object，简称VO，当前函数定义的变量、函数、参数

作用域链：Scope chain，源代码定义时形成的作用域链

函数执行前会进行预编译，产生AO

全局变量在执行前也会有预编译，产生GO

### 创建

函数执行上下文的创建阶段，发生在函数调用时且在执行函数体内的具体代码之前



### 执行

执行阶段中，JS 代码开始逐条执行，在这个阶段，JS 引擎开始对定义的变量赋值、开始顺着作用域链访问变量、如果内部有函数调用就创建一个新的执行上下文压入执行栈并把控制权交出……



### 销毁

正常情况：当前执行上下文（局部环境）会被弹出执行上下文栈(ESC)并且销毁，控制权被重新交给执行栈上一层的执行上下文。

闭包情况：父包裹函数执行完成后，父函数本身执行环境的作用域链会被销毁，但是由于闭包的作用域链仍然在引用父函数的变量对象，导致了父函数的变量对象会一直驻存于内存，无法销毁，除非闭包的引用被销毁，闭包不再引用父函数的变量对象，这块内存才能被释放掉。过度使用闭包会造成 **内存泄露** 的问题，这块等到闭包章节再做详细分析。



```javascript
function foo (c) {
  let a = 1
  let b = function () {}
}

// foo函数的上下文
fooContext = {
  VO: { // 当前函数定义的变量、函数、参数
    arguments: { // 实参
      c: undefind,
      length: 0
    },
    a: 1, // 变量
    b: reference to function (){} // 函数
  },
  Scope: [VO, globalContext.VO], // 作用域链
  this: undefind // 非严格模式下为 this
}
```



## 上下文栈

`上下文栈`又称为执行栈（ECS）, 浏览器中 javascript 解析器本身是单线程的，即同一时间只能处理一个上下文及对应的代码段，所以 javascript 解析引擎使用`上下文栈`来管理`上下文`。

所有的`上下文`创建后会`push`在`上下文栈`队列里，运行完毕后被销毁。

**栈底为全局上下文，栈顶为当前正在执行的上下文**。

```javascript
let i = 0
function fnChild () {
    i++
    console.log(i, 'child')
}
function fnParent () {
    i++
    console.log(i, 'Parent')
    fnChild()
}
fnParent()

/**
- 初始化解析全局代码:  ECStack = [globalContext]
- fnParent调用中, fnChild调用前: ECStack = [fnParentContext, globalContext]
- fnParent调用中, fnChild调用中: ECStack = [fnChild, fnParentContext, globalContext]
- fnParent调用中, fnChild调用完: ECStack = [fnParentContext, globalContext]
- fnParent调用完: ECStack = [globalContext]
**/
```



## 闭包

**闭包是指有权访问另一个函数作用域中变量的函数**

#### 闭包的作用

- 保护函数的私有变量不受外部的干扰。形成不销毁的栈内存。
- 保存，把一些函数内的值保存下来。闭包可以实现方法和属性的私有化



## demo

```javascript
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
var foo = checkscope();
foo();
```

1. 执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈

   ```javascript
   ECStack = [
     globalContext
   ];
   ```

2. 全局上下文初始化

   ```javascript
   globalContext = {
     VO: [global], // 当前函数定义的变量、函数、参数
     Scope: [globalContext.VO], // 作用域链
     this: globalContext.VO
   }
   ```

3. 创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈

   ```javascript
   checkscopeContext = {
     Scope: checkscope.[[scope]],
   }
   
   ECStack = [
     checkscopeContext,
     globalContext
   ];
   ```

4. checkscope 函数执行上下文初始化：

   1. 复制函数 [[scope]] 属性创建作用域链，
   2. 用 arguments 创建活动对象，
   3. 初始化活动对象，即加入形参、函数声明、变量声明，
   4. 将活动对象压入 checkscope 作用域链顶端。

   ```javascript
   checkscopeContext = {
     AO: {
       arguments: {
         length: 0
       },
       scope: undefined,
       f: reference to function f(){}
   	},
     Scope: [AO, globalContext.VO],
     this: undefined
   }
   ```

5. checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出

   ```javascript
   ECStack = [
     globalContext
   ];
   ```

6. 执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈

   ```javascript
   fContext = {
     Scope: fscope.[[scope]],
   }
   
   ECStack = [
     fContext,
     globalContext
   ];
   ```

7. f 执行上下文初始化，创建变量对象、作用域链、this等，同第四步(因为闭包原因，作用域包含checkscopeContext.AO)

   ```javascript
   fContext = {
     AO: {
       arguments: {
         length: 0
       }
     },
     Scope: [AO, checkscopeContext.AO, globalContext.VO],
     this: undefined
   }
   ```

8. f 函数执行完毕，f 函数上下文从执行上下文栈中弹出

   ```javascript
   ECStack = [
     globalContext
   ];
   ```

   

